{"name":"Flakepack","body":"# FlakePack: A decentralized, k-ordered id generation MessagePack service in Scala\r\n\r\nFlakePack is a port of [Flake](https://github.com/boundary/flake) to Scala.\r\n\r\nFlakePack produces 128-bit, k-ordered ids (read time-ordered lexically). Run one on each node in your infrastructure and they will generate conflict-free ids on-demand without coordination.\r\n\r\nRead the original [post](http://blog.boundary.com/2012/01/12/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/) on the Boundary blog.\r\n\r\nFlakePack uses a MessagePack RPC interface through Netty to send it's ids.\r\n\r\nAfter building / getting the right versions for msgpack-rpc (Java) and msgpack-scala, you can run the service through SBT:\r\n\r\n\tsbt run\r\n\r\nThis will start the service on your \"localhost\" ethernet device, with 6000 as default port.\r\nYou can change the default ethernet device and port while starting up:\r\n\r\n\tsbt \"run en0 17000\"\r\n\r\nYou can run a simple test suite to check if everything is working correctly:\r\n\t\r\n\tsbt test\r\n\r\n\r\n# Deployment\r\n\r\nFlakePack is a standalone application. Request ids with a <tt>generateID</tt> through a MessagePack interface.\r\nIf you want to the service to generate multiple ids in one batch, use the generateIDs method and pass the number of ids as a int.\r\n\r\n# Anatomy\r\n\r\nFlakePack ids are 128-bits wide described here from most significant to least significant bits.\r\n\r\n* 64-bit timestamp - milliseconds since the epoch (Jan 1 1970)\r\n* 48-bit worker id - MAC address from a configurable device\r\n* 16-bit sequence # - usually 0, incremented when more than one id is requested in the same millisecond and reset to 0 when the clock ticks forward\r\n\r\n# Frequently Asked Questions\r\n\r\n**How does this differ from snowflake developed at Twitter?**\r\n\r\nThe differences stem primarily from the fact that Twitter snowflake ids are 64-bits wide. This means that additional coordination is required to pick a worker id (twitter does this via a ZooKeeper ensemble) and a new epoch must be defined so that timestamps can fit into a small number of bits. Their scheme works great when your ids must fit into 64-bits. However this comes at the cost of additional coordination among nodes and a system that is generally a little more difficult to reason about. It is a fine system though and we were able to learn from it in our efforts.\r\n\r\n**How is FlakePack different from rearranging the bits of a UUID-1 id?**\r\n\r\nFirst, successive UUID versions aim to make ids increasingly _opaque_ in nature through various means. We have actually found a great deal of utility in structurally transparent unique ids and that has motivated much of this work.  The most transparent variant is UUID-1 (for which it has received a fair bit of criticism) and thus the nearest relative to a flakepack id. There are some important differences though.\r\n\r\nUUID-1 is an odd beast. First, the timestamp is based on the number of 100 nanosecond intervals since October 15, 1582. This is not how most of us familiar with Unix timestamps reason about time. If that isn't bad enough, the timestamp is an odd 60-bits in length with the most significant bits shifted to the least significant bits of the UUID. This property makes lexical ordering essentially meaningless. The remaining bits contain a clock id (initially set to a random number) and a node id (usually the MAC address).\r\n\r\nThe first problem is the timestamp. We could rearrange the bits to get some k-ordering love, but reasoning on timestamps of this nature makes reasoning about the resulting ids more complex than it needs to be. This is why flakepack uses a standard 64-bit Unix timestamp, unaltered, as the most significant bits.\r\n\r\nThe next problem is clock skew and protection against replaying ids for a time in the past. The UUID-1 spec dictates that the clock id be incremented in such an event, but this behavior is implementation-specific and we aren't aware of any Erlang implementations that met our safety goals. Flake durably writes a timestamp to a dets table periodically while running. Following a restart, flakepack will refuse to startup if the timestamp written there is from the future. Furthermore, flakepack will refuse to generate ids if it detects that the system clock is running backwards.\r\n\r\n**When are FlakePack ids _not_ appropriate?**\r\n\r\nFlake ids are predictable by design. Don't use use flakepack to generate ids that you'd rather be unpredictable. Don't use flakepack to generate passwords, security tokens, or anything else you wouldn't want someone to be able to guess.\r\n\r\nFlake ids expose the identity of the machine which generated the id (by way of its MAC address) and the time at which it did so. This could be a problem for some security-sensitive applications.\r\n\r\nDon't do modulo 2 arithmetic on flakepack ids with the expectation of random distribution. The least significant 16-bits are usually going to be 0 on a machine that is generating an average of one or fewer ids per millisecond.\r\n\r\n","tagline":"A decentralized, k-ordered id generation msgpack service in Scala","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}